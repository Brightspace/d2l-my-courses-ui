<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-overlay-behavior/iron-overlay-behavior.html">
<link rel="import" href="../neon-animation/neon-animation-runner-behavior.html">
<link rel="import" href="../neon-animation/animations/slide-from-bottom-animation.html">
<link rel="import" href="../neon-animation/animations/slide-down-animation.html">
<link rel="import" href="../neon-animation/animations/transform-animation.html">
<link rel="import" href="../neon-animation/animations/fade-in-animation.html">
<link rel="import" href="../neon-animation/animations/fade-out-animation.html">
<link rel="import" href="../d2l-icons/d2l-icons.html">
<link rel="import" href="d2l-simple-overlay-styles.html">
<link rel="import" href="localize-behavior.html">
<link rel="import" href="../d2l-polymer-behaviors/d2l-dom.html">

<!--
`<d2l-simple-overlay>` extends `iron-overlay` and adds some styling using various `neon` Polymer elements.

The overlay supports using different animations and transitions for desktop and mobile.
-->
<dom-module id="d2l-simple-overlay">
	<style include="d2l-simple-overlay-styles"></style>
	<template>
		<div class="max-width container">
			<h1 class="d2l-heading-2">{{title}}</h1>
			<button
				class="close-button"
				on-tap="_handleClose"
				aria-label$="{{localize('closeSimpleOverlayAltText')}}"
				alt$="{{localize('closeSimpleOverlayAltText')}}">
				<d2l-icon icon="d2l-tier1:close-large-thick"></d2l-icon>
			</button>
		</div>
		<div class="scrollable">
			<div class="max-width">
				<content></content>
			</div>
		</div>
	</template>
	<script>
		'use strict';

		Polymer({
			is: 'd2l-simple-overlay',

			/*
			* Fired when the overlay is closed, to trigger recalculation of the number of columns
			* @event recalculate-columns
			*/

			behaviors: [
				Polymer.IronOverlayBehavior,
				Polymer.NeonAnimationRunnerBehavior,
				window.D2L.MyCourses.LocalizeBehavior
			],
			listeners: {
				'neon-animation-finish': '_onNeonAnimationFinish',
				'close-simple-overlay': '_handleCloseSimpleOverlayEvent'
			},
			properties: {
				/*
				* Title for overlay
				* @type {String}
				*/
				title: {
					type: String
				},
				/*
				* Animation configuration used by `neon-animation`
				* @type {Object}
				*/
				animationConfig: {
					value: function() {
						return {
							'mobileOpen': {
								name: 'slide-from-bottom-animation',
								node: this
							},
							'mobileClose': {
								name: 'slide-down-animation',
								node: this
							},
							'desktopOpen': [{
								name: 'transform-animation',
								transformFrom: 'scale(.95) translateY(-100px)',
								transformTo: 'scale(1) translateY(0)',
								node: this
							}, {
								name: 'fade-in-animation',
								node: this
							}],
							'desktopClose': [{
								name: 'transform-animation',
								transformFrom: 'scale(1) translateY(0)',
								transformTo: 'scale(.95) translateY(-100px)',
								node: this
							}, {
								name: 'fade-out-animation',
								node: this
							}]
						};
					}
				},
				/*
				* Focusable element override for `iron-overlay`
				*
				* Required for accessibility, this specifies which elements within the element are intended to be
				* keyboard-focusable. This is because we're using `<iron-overlay with-backdrop>`. See
				* [those docs](https://github.com/PolymerElements/iron-overlay-behavior#backdrop) for more information.
				*/
				focusableNodesOverride: {
					type: Object,
					value: null
				},
				/* TODO: No longer required? */
				_viewportContent: {
					type: String
				},
				/* TODO: No longer required? */
				_restoreViewportContent: {
					type: Boolean
				},
				// For restoring the document overflow when the overlay is closed
				_oldBodyOverflow: {
					type: String,
					value: null
				}
			},
			created: function() {
				this._updateBackdropStyle();
			},
			ready: function() {
				new MutationObserver(this.invalidateTabbables.bind(this)).observe(this, {
					childList: true,
					subtree: true
				});
			},
			get _focusableNodes() {
				return [D2L.Dom.Focus.getFirstFocusableDescendant(this), D2L.Dom.Focus.getLastFocusableDescendant(this)];
			},
			_handleClose: function() {
				this.close();
				this.fire('recalculate-columns');
			},
			_handleCloseSimpleOverlayEvent: function(e) {
				e.preventDefault();
				e.stopPropagation();
				this._handleClose();
			},
			_isMobile: function() {
				var width = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
				return width < 768;
			},
			_onNeonAnimationFinish: function() {
				if (this.opened) {
					this._finishRenderOpened();
				} else {
					this._finishRenderClosed();
				}
			},
			_renderClosed: function() {
				this.cancelAnimation();
				this._restoreBodyOverflow();

				if (this._isMobile()) {
					this.playAnimation('mobileClose');
				} else {
					this.playAnimation('desktopClose');
				}
			},
			_renderOpened: function() {
				this.cancelAnimation();
				this._trapBodyOverflow();

				this._onNodesChange();
				Polymer.dom(this.root).querySelector('.scrollable').scrollTop = 0;

				if (this._isMobile()) {
					this.playAnimation('mobileOpen');
				} else {
					this.playAnimation('desktopOpen');
				}
			},
			_restoreBodyOverflow: function() {
				document.body.style.overflow = this._oldBodyOverflow;
				this.oldBodyOverflow = undefined;
			},
			_trapBodyOverflow: function() {
				this._oldBodyOverflow = document.body.style.overflow;
				document.body.style.overflow = 'hidden';
			},
			_updateBackdropStyle: function() {
				var style = document.createElement('style', 'custom-style');
				style.innerHTML = 'iron-overlay-backdrop { --iron-overlay-backdrop-opacity: 0.0; }';
				document.body.appendChild(style);
			},
			get scrollRegion() {
				return this.$$('.scrollable');
			}
		});
	</script>
</dom-module>
