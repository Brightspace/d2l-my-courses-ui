<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="d2l-touch-menu-styles.html">

<dom-module id="d2l-touch-menu">
	<template>
		<style include="d2l-touch-menu-styles"></style>

		<div class="long-press-menu">
			<content></content>
		</div>
	</template>

	<script>
		Polymer({
			is: 'd2l-touch-menu',
			properties: {
				enabled: {
					type: Boolean
				},
				_touchTarget: {
					type: Object,
					observer: '_touchTargetChanged'
				},
				_longPressDuration: {
					type: Number,
					value: 500
				},
				_menuItemInitialOffset: {
					type: Object
				},
				_menuOpen: {
					type: Boolean,
					observer: '_onMenuOpenChanged'
				},
				_openMenuTimerID: {
					type: Number,
					value: null
				},
				_enableClicksTimerID: {
					type: Number,
					value: null
				},
				_touchHandlers: {
					Type: Array,
					value: [{
						event: 'touchstart',
						handler: 'touchstartHandler'
					},  {
						event: 'touchend',
						handler:  'touchendHandler'
					}, {
						event: 'touchcancel',
						handler:  'touchcancelHandler'
					}, {
						event: 'touchmove',
						handler: 'touchmoveHandler'
					}, {
						event: 'click',
						handler: 'clickHandler'
					}]
				},
				_host: {
					type: Object
				},
				_menu: {
					type: Object
				},
				_menuItems: {
					type: Array
				},
				_owner: {
					type: Object
				},
				_initialized: {
					type: Boolean
				},
				_cancelClicks: {
					type: Boolean
				}
			},
			listeners: {
				'contextmenu': 'contextMenuHandler'
			},
			ready: function() {
				this._menu = this.$$('.long-press-menu');
				this._menuItems = [].slice.call(Polymer.dom(this).querySelectorAll('d2l-touch-menu-item'));
			},
			attached: function() {
				if (this.enabled && !this._initialized) {
					// Only run once, as attaching to body will cause this to be called again
					this._initialized = true;
					this._owner = this.parentNode;
					this._host = Polymer.dom(this).parentNode.host;

					if (!this._touchTarget) {
						this._touchTarget = this._host;
					}

					// We need to catch contextmenu events both directly from this element, and separetly from the touch target,
					// as each will be the target of that event under different circumstances (typically, this element will be the target
					// when there is no active scroll event, and the touch target will be the event target when there is a scroll event)
					this.listen(this._touchTarget, 'contextmenu', 'contextMenuHandler');
				}
			},
			touchstartHandler: function(e) {
				// Only show the menu if it's tap+hold
				this._openMenuTimerID = setTimeout(this.openMenu.bind(this, e), this._longPressDuration);
			},
			touchmoveHandler: function(e) {
				if (this._menuOpen) {
					var touchPoint = {
						x: e.changedTouches[0].clientX,
						y: e.changedTouches[0].clientY
					};

					//If we can cancel the pending move, do so, so we don't scroll the page while attempting to navigate the menu.
					if (e.cancelable) {
						e.preventDefault();
						e.stopPropagation();
					}
					else {
						//Otherwise, terminate the touch (though this shouldn't be visible at this point anyway
						this.touchendHandler();
					}

					this._menuItems.forEach(function(menuItem) {
						menuItem.hoverState = menuItem.pointInTouchRegion(touchPoint);
					}.bind(this));
				} else {
					clearTimeout(this._openMenuTimerID);
				}
			},
			touchendHandler: function(e) {
				// When finger is released, if the item is selected, then do the fancy animation
				this._menuItems.forEach(function(menuItem) {
					if (menuItem.hoverState === true) {
						menuItem.selected = true;

						if (menuItem.selectionHandler) {
							this.async(this._host[menuItem.selectionHandler].bind(this._host));
						}
					}
				}.bind(this));

				this.touchcancelHandler(e);
			},
			touchcancelHandler: function() {
				clearTimeout(this._openMenuTimerID);

				this._menuOpen = false;
			},
			openMenu: function(touchstartEvent) {
				this.listen(this._touchTarget, 'touchend', 'touchendHandler');

				var touchData = {
					startX: touchstartEvent.changedTouches[0].pageX,
					startY: touchstartEvent.changedTouches[0].pageY,
					clientX: touchstartEvent.changedTouches[0].clientX,
					clientY: touchstartEvent.changedTouches[0].clientY
				};

				var menuPosX = touchData.clientX;
				var menuPosY = touchData.clientY;

				this._menu.style.left = menuPosX + 'px';
				this._menu.style.top = menuPosY + 'px';

				// For now, only deal with one menu item
				var menuItem = this._menuItems[0];
				var radius = menuItem.height * 1.3;
				var translationCoefficient = 1.1;
				var horizontalExpansionRoom = radius + (menuItem.width * 2);
				var verticalExpansionRoom = radius + (2 * menuItem.height * translationCoefficient);
				var nearLeftEdge = menuPosX < menuItem.width;
				var nearRightEdge = menuPosX > (window.innerWidth - menuItem.height);
				var layoutDirX = 0;
				var layoutDirY = 0;

				if (menuPosY < verticalExpansionRoom) {
					layoutDirX = -1.0;

					if (menuPosY < menuItem.height) {
						layoutDirX = -0.707;
						layoutDirY = 0.707;
					} else if (menuPosY > (verticalExpansionRoom * 0.707)) {
						layoutDirX = -0.707;
						layoutDirY = -0.707;
					}

					// Not enough room to expand to left; switch to right
					if (menuPosX < (-horizontalExpansionRoom * layoutDirX)) {
						layoutDirX *= -1;
					}
				} else if (nearLeftEdge || nearRightEdge) {
					// If we're near a border, we can always go up-away from that side
					var xDir = nearLeftEdge ? 1.0 : -1.0;

					layoutDirX = xDir * 0.707;
					layoutDirY = -0.707;
				} else {
					// Set above touch point
					layoutDirY = -1.0;
				}

				var menuItemPosition = {
					x: -(menuItem.width / 2) + (layoutDirX * radius),
					y: -(menuItem.height / 2) + (layoutDirY * radius)
				};

				menuItem.customStyle['--translate-x-coefficient'] = (translationCoefficient * layoutDirX).toString();
				menuItem.customStyle['--translate-y-coefficient'] = (translationCoefficient * layoutDirY).toString();
				menuItem.updateStyles();

				menuItem.offset = menuItemPosition;
				menuItem.touchRegion = {
					left: menuPosX + menuItemPosition.x,
					top: menuPosY + menuItemPosition.y
				};

				this._menuOpen = true;
			},
			_touchTargetChanged: function(newValue, oldValue) {
				if (oldValue !== null) {
					this._touchHandlers.forEach( function(handlerData) {
						this.unlisten(oldValue, handlerData.event, handlerData.handler);
					}.bind(this));
				}

				if (newValue !== null) {
					this._touchHandlers.forEach( function(handlerData) {
						this.listen(newValue, handlerData.event, handlerData.handler);
					}.bind(this));
				}
			},
			contextMenuHandler: function(e) {
				e.preventDefault();
			},
			_onMenuOpenChanged: function(openMenu) {
				this._menu.style.visibility = openMenu ? 'visible' : 'hidden';

				if (openMenu) {
					this._cancelClicks = true;
				} else {
					// iOS will send delayed click on long press completion, so we need to slightly delay re-enabling clicks
					this._enableClicksTimerID = setTimeout(this._enableClicks.bind(this), 100);
				}

				this._menuItems.forEach(function(menuItem) {
					menuItem.visible = openMenu;
				}.bind(this));
			},
			clickHandler: function(e) {
				if (this._cancelClicks) {
					e.preventDefault();
					this._enableClicks();
				}
			},
			_enableClicks: function() {
				this._cancelClicks = false;
				clearTimeout(this._enableClicksTimerID);
				this._enableClicksTimerID = null;
			}
		});
	</script>
</dom-module>
